---
layout: article
title: A guide to getting started with VIM
strapline: I explain how you can get started using VIM as your main editor and development environment, by focusing on installing some important plug-ins that are essential for a good VIM experience
---

## What we'll cover *reading time: approx. 22mins*

- Introduction
- Here comes the old man
- The focus of this post
- Step 1: Installation
- TMUX
- TMUXinator
- Vundle
	- Set-up some bundles
	- Where can I find bundles?
- NERDTree
- Ctrl+P
- VIM Basics
- VIM Configuration
- Other plugins
- Conclusion

## Introduction

So, what editor do you use for programming?

In case you're wondering, here is the list of editors I've tried at one point or another…

- Homesite
- DreamWeaver
- NetBeans
- Aptana
- Coda
- Chocolat
- Sublime Text

…and that's not including some of the real *random* editors that have cropped up over the years.

It seems popular editors nowadays are becoming more minimalist (oxymoron?)

The UI appears to be reducing in favour of keyboard short-cuts, with the intention of improving developer productivity.

One example of this is the use of a 'fuzzy keyword search'. The principle idea being that you press a short-cut key and you're presented with a field where you can type whatever you like and the editor will attempt to list out a group of files that match (in some way) what you've typed.

The reason this is a good thing is that it makes finding and opening files a lot quicker.

Imagine you don't know where a file lives (easily done in a cross team environment where other devs are working on code for a feature you're not). Fuzzy file searching makes life a lot easier.

Even if you *do* know where a file lives, fuzzy file searching is still quicker than reaching for your mouse, moving over to the file system and clicking on folders until you find the file and then double click to open it.

A lot of editors have a feature like this nowadays (Sublime Text is one such popular example).

<div class="delayed-image-load" data-src="Assets/Images/src/generated/sublime-text-fuzzy-1024.png" data-width="1024"></div>

The problem is that most editors don't normally have a long shelf life (none that any serious developer would consider using  nowadays -> I'm looking at Dreamweaver here**).

**yes I'm sure they'll be some people who still use Dreamweaver and will not like that sentence, but I think it's safe to say that the developer community has grown up considerably since those early Macromedia days and developers have long since moved away to other more advanced and efficient development environments.

For example, the current hotness (as of 2013) is to use Sublime Text (a nice editor with good keyboard based features but also allows users to interact with it using a mouse). But what happens when Sublime Text stops getting updates (TextMate? Don't think it can't happen), or gets bought out by a competitor and then is dumped (this happens *all* the time in the software industry)?

Where do developers go next?
Typically developers find another editor.

## Here comes the old man

Well, there is an editor that has been around for a *very* long time and is available everywhere (and in most cases is installed by default) but also has tons of plug-ins and is pretty much the Perl of keyboard short-cuts.

That editor is [VI](http://en.wikipedia.org/wiki/Vi) (well, as you'll see, more specifically VIM) and it was originally created back in 1976!

Since then there has been improvements to the editor which nowadays (~1981 onwards) is more commonly known as VIM (meaning: VI Improved) and you can find more information on VIM at its website [http://www.vim.org/](http://www.vim.org/).

## The focus of this post

OK, so the problem with VIM is that although it's a great program to use, it unfortunately has a *very* steep learning curve which puts off new comers.

Also, VIM by itself isn't as useful (as a development environment) without a few plug-ins that help give it a bit of jazz. That also trips up new comers to VIM as they assume what they see other developers using is *just* VIM but it's not. VIM by itself is very nondescript, it's the plug-ins and custom VIM configurations that make all the difference to the look and feel of VIM.

So, the key to using VIM (for the first time) as a developer tool is:

- Get a nice clean command line shell
- Get ourselves a set of primary plugins installed first
- Then focus on basic VIM commands last (typically this is considered the first step, but I think that's a mistake)

I want to get the primary tools set-up first, and to show you those BEFORE we get ourselves bogged down with VIM commands.

## Step 1: Installation

I'm not going to cover the installation of VIM because chances are it's already installed! Also, I'm running a Mac and so this tutorial is aimed at that environment (i.e. your mileage may vary otherwise if you're on Windows or a non Unix system).

But here are the things we're going to install…

- Pure Zsh
- TMUX
- Vundle
- NERDTree
- Ctrl+p

…now there are loads of plugins you could install but the above are the fundamental ones that you'll require (you might decide that's all you need, I'll leave it up to you to decide).

## Zsh

To use VIM we'll need to use a terminal shell. So let's get that open now (if you're on a Mac you'll have a Terminal.app you can run).

The default terminal shell for the GNU operating system, Linux and Mac OS X is 'Bash' but we want to use 'Zsh' instead.

I won't delve into the reasons why but effectively Zsh is a more efficient shell and offers better features than Bash and in general is more enjoyable to use.

To see what shells are available on your system you can run the command `cat /etc/shells` (hopefully you'll see `/bin/zsh` in the list).

To change shells run the command `chsh -s /bin/zsh`.

Terminal shells can be configured using (what's typically referred to as) a 'dot file'. These are files that are prefixed with a period character and so are hidden from standard users.

To see the hidden files in a directory just run the command `ls -la` and you should see a whole host of hidden dot files and folders.

For Zsh there should be a `.zshrc` file in your home directory (if there isn't then create one, as we'll need it shortly). You can do this very simply using the command `touch .zshrc`.

As we'll be using VIM there should also be in the home directory a `.vimrc` file for configuring VIM. If there isn't then create one (again, we'll be needing it shortly).

## Pure Zsh

Now that we have Zsh running let's make it look a bit nicer by using 'Pure Zsh'. I'm going to let the author have the pleasure of describing it…

> Most prompts are cluttered, ugly and slow. I wanted something visually pleasing that stayed out of my way. Pretty, minimal and fast.

So let's get it installed. Go to [https://github.com/sindresorhus/pure](https://github.com/sindresorhus/pure) and download the file `pure.zsh` to your home directory (or wherever you want, just remember where you save it).

You can import the `pure.zsh` file by adding the following line into the `.zshrc` file: `. /path/to/pure.zsh`

<div class="delayed-image-load" data-src="Assets/Images/src/generated/pure-zsh-1024.png" data-width="1024"></div>

## TMUX

So what is tmux? The authors definition is…

> It lets you switch easily between several programs in one terminal, detach them (they keep running in the background) and reattach them to a different terminal. And do a lot more.

OK, so in short tmux makes it easy for you to create new terminal windows with panes and complex layouts (stuff you can do with raw VIM but tmux makes easier).

There are a couple of ways to install [TMUX](http://tmux.sourceforge.net/) the easiest is with [Homebrew](http://brew.sh/): `brew install tmux`

Once you have tmux installed you can start it by simply running the command `tmux` in your terminal.

You may wonder if anything has actually happened because tmux doesn't look any different from what your normal terminal shell looks like, but what you don't realise is that you now have quite a few new keyboard shortcuts you can use to split your terminal into 'panes', 'windows' or 'tabs'.

<div class="delayed-image-load" data-src="Assets/Images/src/generated/tmux-1024.png" data-width="1024"></div>

### Prefix?

In tmux whenever you want to run a command you first run a opening command called 'the prefix'. The prefix is typically `Ctrl+b` (i.e. press the `Ctrl` button and then the `b` key). 

In my case I've updated the prefix to be `Ctrl+a` instead of `Ctrl+b` via a `tmux.conf` configuration file (you'll find out more about this file in the next section "tmuxinator").

### Creating windows

To create a new window just run the prefix command and then press the `c` key (e.g. `Ctrl+b` then `c`)

To close a window either run `exit` or press `Ctrl+d`

### Renaming windows

You can rename a window by running the prefix command and then pressing the `,` key.

### Creating panes

To create a new horizontal pane run the prefix command and then press `Shift+5` (the `%` key).

<div class="delayed-image-load" data-src="Assets/Images/src/generated/tmux-horizontal-1024.png" data-width="1024"></div>

To create a new vertical pane run the prefix command and then press `Shift+'` (the `"` key).

<div class="delayed-image-load" data-src="Assets/Images/src/generated/tmux-vertical-1024.png" data-width="1024"></div>

### Full screen a pane

At any time you can turn a pane into a full screen view (and back again) by running the prefix command followed by `z`. Run that again to toggle back to the pane view.

### Move a pane into a different pane space

You can actually shift the panes around so that if a pane is in one position (let's say top left), you can move it to a different location (let's say bottom right) simply by running the prefix command followed by `Shift+{`, every time you press that combination all the panes will shift around.

### Renaming a session

When you create a new tmux session (i.e. run `tmux`). You can opt to give it a name using `tmux new -s session_name`, but if you forget to do that and want to give the session a name later on (I do this all the time) then from within the session just run the prefix command followed by `Shift+4` (which is the `$` key) or alternatively run the prefix command followed by a `:` and then `rename-session -t [current-name] [new-name]` (if it has no current name then you'll just use the number assigned).

## TMUXinator

We're now going to set-up a tool associated with tmux called '[tmuxinator](https://github.com/aziz/tmuxinator)' and this will help us manage complex tmux sessions.

Basically, rather than you (every day) opening up the terminal and manually creating the same set of panes and windows and opening files in tmux, we can just store these preferences as a template. We do this by creating a text file that holds this configuration information.

First thing to do is to install TMUXinator.

Sorry, but we need more technologies and this time it's Ruby.

To install it we need to run the command `gem install tmuxinator`.

Once installed we can create a new instance by running the command `tmuxinator new [project]`. You can call your project whatever you like (I went with `tmuxinator new work`).

Running this command is going to create a dot file `.tmux.conf` and also a dot folder called `.tmuxinator` which holds a `project.yml` (where the name of the file matches the name of the project, so for me it created a `work.yml` file).

If you open the yaml file you'll see it has a basic example set-up ready for you to configure…

{% highlight yaml %}
    name: test-project
    root: ~/Code/news/workspace/

    windows:
      - editor:
          layout: main-vertical
          panes:
            - vim
            - git status
            - cd path/to/my/cheatsheet && vim cheat-sheet.txt
      - sandbox: vagrant ssh
      - sass: grunt watch:service:news
{% endhighlight %}

…above is an example of my `work.yml`.

You can see I specify that I want to have three tabs created:

- editor
- sandbox
- sass

Within the first tab `editor` I have a specific layout used called `main-vertical` (tmux comes with many different pre-built layouts, this is just one of them).

The layout I'm using splits the screen into two columns. In the left column I have `vim` running and in the right column I have two rows. The top row checks the status of my git repository, and the bottom row opens up a VIM cheat sheet.

In the second tab `sandbox` I've told tmux I want to connect to our local development sandbox (via ssh).

In the third tab `sass` I've told tmux I want to run a task that watches our Sass development files for any changes (and then compiles the files when a change is detected).

<div class="delayed-image-load" data-src="Assets/Images/src/generated/tmuxinator-1024.png" data-width="1024"></div>

### Starting tmuxinator

Now we have a template set-up, to use it we just run `tmuxinator start project` (or in my case `tmuxinator start work`).

### Closing tmux

Chances are you'll just leave the tmux session open, but if you want a quick way to detach from the tmux session (but leave the session open in the background so you can come back to it) then just run `Ctrl+a d`

You can see what tmux sessions are still open by running `tmux ls` which will show a number and a associated session.

You can re-attach to an existing session by running `tmux attach -t {number|name}` where `{number|name}` is either the number or the name of the session.

If there is only one session then you can just run `tmux attach`.

To totally kill a session just run `tmux kill-session -t {number|name}`.

## Vundle

This is a plug-in manager for VIM.

To install Vundle run `git clone  
https://github.com/gmarik/  
vundle.git  
~/.vim/bundle/vundle`

Now you have it installed, you can add plug-ins to your `.vimrc` configuration file and install them by running a `:BundleInstall` command from within VIM.

### Set-up some bundles

We're jumping ahead a little bit (because at the end of this section you'll see we'll be using VIM to type one command, but it's OK we won't do any more than that until later).

Let's open our `.vimrc` file and add some plug-ins we're going to need (code comments start with ")…

{% highlight bash %}
		set rtp+=$HOME/.vim/bundle/vundle
		call vundle#rc()
		Bundle 'gmarik/vundle'
		filetype plugin indent on

		" ALL OF THE ABOVE IS ALSO REQUIRED
		" FOR SUCCESSFUL VUNDLE INSTALL
		" THE FOLLOWING IS NEW FOR US…

		Bundle 'kien/ctrlp.vim'
		Bundle 'vim-scripts/The-NERD-tree'
{% endhighlight %}

…so you may have noticed we've specified two plug-ins:

1. NERDTree
2. Ctrl+p

If you check the Vundle README on GitHub you'll see there are multiple ways to specify a 'bundle', in our case we're installing two bundles that are available on GitHub so you'll notice that the paths specified are actually the GitHub username/repo-name.

To actually get these two bundles installed (using the Vundle plug-in) means we need to first open VIM so we can run the relevant install command.

So to open VIM literally just run: `vim` and then to run the install command press ESC (just to make sure you're in the right mode, don't worry we'll cover this later) then type `:BundleInstall` and press ENTER.

### Where can I find bundles?

Bundles are just pointers to VIM scripts.

The two bundles we've pointed to are references to their GitHub repositories.

But you can also point to non-github repos, local git repos, or direct to VIM scripts. See the Vundle README for more information.

## NERDTree

NERDTree is a tree explorer plugin for navigating the filesystem. This is the closest thing you're going to get to a standard editor feature.

We'll cover how to use it in the following VIM Basics section. Suffice to say, with the `Ctrl+p` plug-in we shouldn't need to use the NERDTree very often (but sometimes it can come in handy)

## Ctrl+p

This is a fuzzy file finder so it makes it easy for you to locate files within your project by just typing a couple of characters of the files name.

Again, we'll cover how to use it in the following VIM Basics section.

## VIM Basics

So here we are! We made it to the part where we can actually use VIM!

VIM is all about not using the mouse, just the keyboard.

One of the first things to know about VIM are that it has 3 modes:

1. NORMAL (you run the majority of your commands from this mode)
2. INSERT (you spend the least amount of time in this mode)
3. VISUAL (you select text in this mode)

To switch modes you first press the `ESC` key and then either `i` to go into INSERT mode and `v` to go into VISUAL mode. The act of pressing `ESC` automatically puts you into NORMAL mode.

Once you're in NORMAL or VISUAL mode, to actually run a command (let's say the command we want is `d$`, don't worry what that means for now) you first press `:` followed by `d$`.

### Using Ctrl+p to do fuzzy file searching

Get ourselves into NORMAL mode by pressing `ESC`, followed by `:`, followed by `CtrlP` (note: for this particular plug-in, if you're already in NORMAL mode, you can just press the `Ctrl` and `p` keys together to trigger the fuzzy search to open, but to not confuse ourselves let's keep to the standard `:some-command` format).

Once the plug-in is open we can just start typing the name of the file we're looking for, and you'll see that it lists all the files it thinks matches what we're looking for.

Simply use the arrow keys to select the relevant file you want to open and press ENTER.

<div class="delayed-image-load" data-src="Assets/Images/src/generated/ctrlp-1024.png" data-width="1024"></div>

### Using NERDTree to search our file system

When VIM is open and in NORMAL mode press `:` followed by `NERDTreeToggle` this will open NERDTree at the current location. You can then use your arrow keys to move up and down the file system and press `ENTER` to open folders. Once you find a file you want to open press `ENTER` once you're cursor is on the item of interest.

<div class="delayed-image-load" data-src="Assets/Images/src/generated/nerdtree-1024.png" data-width="1024"></div>

### More Commands

It's worth remembering that most commands follow the format: `operator [number] motion` (not all the time, but enough of the time - you'll soon get used to the order you do things).

What follows is a super short list of commands and what they do.

### Cursor Movement

`h`	: left  
`l`	: right  
`k`	: up  
`j`	: down

Note: you can use your arrow keys still, but it's considered best practice by the VIM community to get used to using the above keys rather than the arrow keys.

### Page Movement

Rather than moving up and down a file line by line, we can instead just move up and down the file in sections.

`Ctrl+u` : move one page up  
`Ctrl+d` : move one page down  
`Ctrl+b` : move half page up  
`Ctrl+f` : move half page down

### Motions

With some commands we need to indicate what direction or motion we want to take.

`e`	: move to the end of a word
`w`	: move to the start of next word (use with a counter -> a counter meaning "a number")

**Examples**:

`5e` = move to the end of the 5th word in the sentence
`5w` = move to the start of the word after the 5th (so actually move to the start of the 6th word)

### Operators

Here are some common operators available to use:

- `0` : moves cursor to the start of the line
- `$` : moves cursor to the end of the line
- `d` : delete (e.g. `d$` deletes the entire line)
- `G` : go to line (e.g. `5G` takes you to the 5th line of the file)
- `v`	: select (e.g. `v1e` selects one word, the act of pressing `v` automatically sticks you in VISUAL mode)
- `V`	: select entire line (e.g. `V` selects the entire line, the act of pressing `v` automatically sticks you in VISUAL mode)
- `j`	: move down one line (e.g. `d5j` deletes 5 lines)
- `y` : copy selected text (e.g. select text and then press `y`)
- `yy`	: copy line (e.g. `yy` copies line to buffer ready to be pasted)
- `p`	: paste after cursor (e.g. `p` pastes content, but obviously requires content to have been copied previously)
- `P`	: paste before cursor (e.g. `P` pastes content, but obviously requires content to have been copied previously)
- `c`	: change (the change command deletes the selection and then puts user into INSERT mode so e.g. `cw` deletes the current word ready to have a new word entered)
- `i`	: inside of (e.g. `yi"` this will (y)ank all content (i)nside of the next set of quotation marks)
- `a` : same as `i` but content comes after the cursor rather than before
- `o` : moves cursor to the next line and jumps into insert mode
- `f`	: forward (e.g. `f,` moves to first comma. if you then press `;` you'll move to the next instance of the specified character. You can also move a set number of characters, so `2f,` will move the cursor to the second instance of a comma)
- `x`	: cut after cursor (e.g. place cursor where you want to cut a character and press `x` to cut it, ready for pasting elsewhere)
- `u`	: undo (e.g. just pressing `u` will undo the last change made)

### Search and Replace

You can search and replace within a file by first moving into NORMAL mode and then after pressing `:` and entering the following…

`50,100s/search/replace/gc`

…what this means is we limit the search range from line 50 up to line 100, we then look for the phrase `search` and we replace it with the phrase `replace`. We then use the `g` global flag which means don't stop after finding the first match. The `c` flag means don't just replace the instance, check with us first by asking us if we definitely want to carry out the replace.

You don't have to use the range numbers, you can just use: `:%s/search/replace/gc` (but notice, now we don't have the range we need to include a `%` at the start).

You can also use regular expressions which is awesome.

Note: You can also do a site wide search and replace using the `Ack` plug-in (e.g. add `Bundle 'mileszs/ack.vim'` to our `.vimrc` file and run the `:BundleInstall` again). Checkout the Ack repo on GitHub to see how it works.

### Viewing different buffers

Our `.vimrc` maps `\y`…

`map <leader>y :CtrlPBuffer<cr>`

…so it shows us what the current buffer is (this allows us to jump between files within VIM).

Note: in VIM the `<leader>` key is a backslash `\`

### Code Comments

The following commands use the `vim-commentary.git` plugin…

`gcc` = comment out a line  
`gcu` = uncomment the commented line

### Syntax Formatting

You can set the formatting of a file using `:setf`

e.g. `:serf cucumber` (where `cucumber` is a syntax format installed)

### Run terminal commands within VIM

Running the prefix command and then typing `:!{terminal command}` allows you to run terminal commands from within vim (e.g. `:!pwd` shows us the current working directory).

Note: doing this takes you out of VIM so you can see the results, but if you just press `ENTER` you'll be sent back into VIM.

### Suspend VIM

Another way to run terminal commands while VIM is running is to actually suspend VIM.

If you run the prefix command this will take us back to the terminal to run whatever commands we like and then in the terminal just type `fg` to bring VIM back to the (f)ore (g)round.

### Visual Block Mode

`Ctrl+v` puts us into Visual Block mode which allows us to select single columns and make multiple changes. So for example if you have a long list of items such as…

```
_List Item 1
_List Item 2
_List Item 3
_List Item 4
_List Item 5
```

…if you wanted to remove the opening `_` underscore then you could enter Visual Block mode, select the underscores by using the direction keys (make sure you're on the first or last underscore when you enter Visual Block mode) and then after all are selected just press `d` to delete them.

### Keep to the basics

The above commands quite literally do not even scratch the surface of what's available within VIM.

So the best thing to do is to find a comfortable set of commands from the list above and don't deviate from them until you've got them memorised (it's ok to Google for something you don't know, but try to just focus on the basic commands for now).

## VIM Configuration

Let's now take a quick look at some configuration options we can add to our `.vimrc` file…

{% highlight bash %}
    " switch syntax highlighting on, when the terminal has colors
    syntax on

    " use vim, not vi api
    set nocompatible

    " no backup files
    set nobackup

    " no write backup
    set nowritebackup

    " no swap file
    set noswapfile

    " command history
    set history=100

    " always show cursor
    set ruler

    " show incomplete commands
    set showcmd

    " incremental searching
    set incsearch

    " highlight search
    set hlsearch

    " ignore case in search
    set smartcase

    " clear search buffer
    :nnoremap § :nohlsearch<cr>

    " make sure undo history is kept for files in buffer.
    set hidden

    " turn indentation on
    filetype indent on

    " enable filetype plugins
    filetype plugin on

    " disable folding because it is evil
    set nofoldenable

    " turn word wrap off
    set nowrap

    " scroll with more context
    set scrolloff=10

    " allow backspace to delete end of line, indent and start of line characters
    set backspace=indent,eol,start

    " convert tabs to spaces
    set expandtab

    " set tab size
    set tabstop=4

    " the number of spaces inserted for a tab
    set shiftwidth=4

    " turn on line numbers
    set number

    " highlight tailing whitespace
    set list listchars=tab:\ \ ,trail:·

    " get rid of the delay when pressing O (for example)
    " http://stackoverflow.com/questions/2158516/vim-delay-before-o-opens-a-new-line
    set timeout timeoutlen=1000 ttimeoutlen=100

    " always show status bar
    set laststatus=2

    " set the status line to something useful
    set statusline=%f\ %=L:%l/%L\ %c\ (%p%%)

    " hide the toolbar
    set guioptions-=T

    " utf encoding
    set encoding=utf-8

    " autoload files that have changed outside of vim
    set autoread

    " jump to last cursor
    autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal g`\"" |
      \ endif

		" set-up ctrlp to include hidden files in its search
    let g:ctrlp_show_hidden=1

		" disable ctrlp's feature where it tries to intelligently work out the current working directory to search within
    let g:ctrlp_working_path_mode=0

		" don't let ctrlp take over the screen!
    let g:ctrlp_max_height=30

		" lets make sure we don't show these files
		set wildignore+=*/.git/*,*/.hg/*,*/.svn/*.,*/.DS_Store

    " allows us to more easily work with markdown files
    Bundle 'tpope/vim-markdown'

    " allows us to comment/uncomment lines and content
    Bundle 'tpope/vim-commentary.git'

    " remove whitespace on save
    autocmd BufWritePre * :%s/\s\+$//e
{% endhighlight %}

…hopefully the comments are self explanatory. There is so much you can configure with VIM that you just need to take the time to look at what set-up works for you, as chances are you'll be able to change it.

You can find loads of VIM configurations on GitHub where you can pinch ideas and settings from.

## Other plugins

Here are some other really useful plugins worth your time investigating… 

- Sparkup (ZenCoding/Emmet) [NetTuts Screencast](http://net.tutsplus.com/tutorials/other/vim-essential-plugin-sparkup/)
- Snipmate [NetTuts Screencast](http://net.tutsplus.com/tutorials/other/vim-essential-plugin-snipmate/)

## Conclusion

So there you have it. A painfully short introduction to using VIM as your new web development environment. But hopefully enough to get you started.

VIM is so powerful that it would probably take a life time to really cover everything. It just takes dedication.